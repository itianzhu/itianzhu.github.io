<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | tz's Blog]]></title>
  <link href="http://itianzhu.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://itianzhu.github.io/"/>
  <updated>2013-12-22T22:42:58+08:00</updated>
  <id>http://itianzhu.github.io/</id>
  <author>
    <name><![CDATA[tz]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby调试]]></title>
    <link href="http://itianzhu.github.io/blog/2013/12/22/rubydiao-shi/"/>
    <updated>2013-12-22T22:16:47+08:00</updated>
    <id>http://itianzhu.github.io/blog/2013/12/22/rubydiao-shi</id>
    <content type="html"><![CDATA[<p>开始调试
<code>
$ ruby -r debug test.rb
</code>
支持的命令，参考<a href="http://www.zenspider.com/Languages/Ruby/QuickRef.html#debugger">http://www.zenspider.com/Languages/Ruby/QuickRef.html#debugger</a>
```
b[reak] [file:|class:]&lt;line|method
b[reak] [class.]&lt;line|method</p>

<pre><code>                       set breakpoint to some position
</code></pre>

<p>wat[ch] expression         set watchpoint to some expression
cat[ch] exception          set catchpoint to an exception
b[reak]                    list breakpoints
cat[ch]                    show catchpoint
del[ete][ nnn]             delete some or all breakpoints
disp[lay] expression       add expression into display expression list
undisp[lay][ nnn]          delete one particular or all display expressions
c[ont]                     run until program ends or hit breakpoint
s[tep][ nnn]               step (into methods) one line or till line nnn
n[ext][ nnn]               go over one line or till line nnn
w[here]                    display frames
f[rame]                    alias for where
l[ist][ (&ndash;|nn-mm)]         list program, &ndash; lists backwards</p>

<pre><code>                       nn-mm lists given lines
</code></pre>

<p>up[ nn]                    move to higher frame
down[ nn]                  move to lower frame
fin[ish]                   return to outer frame
tr[ace] (on|off)           set trace mode of current thread
tr[ace] (on|off) all       set trace mode of all threads
q[uit]                     exit from debugger
v[ar] g[lobal]             show global variables
v[ar] l[ocal]              show local variables
v[ar] i[nstance] object    show instance variables of object
v[ar] c[onst] object       show constants of object
m[ethod] i[nstance] obj    show methods of object
m[ethod] class|module      show instance methods of class or module
th[read] l[ist]            list all threads
th[read] c[ur[rent]]       show current thread
th[read] [sw[itch]] nnn    switch thread context to nnn
th[read] stop nnn          stop thread nnn
th[read] resume nnn        resume thread nnn
p expression               evaluate expression and print its value
h[elp]                     print this help
everything else            evaluate
empty                      repeats the last command
```
或者使用<a href="http://bashdb.sourceforge.net/ruby-debug.html">ruby-debug</a>等</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby the Standard Protocols and Coercions]]></title>
    <link href="http://itianzhu.github.io/blog/2013/12/22/ruby-the-standard-protocols-and-coercions/"/>
    <updated>2013-12-22T21:51:24+08:00</updated>
    <id>http://itianzhu.github.io/blog/2013/12/22/ruby-the-standard-protocols-and-coercions</id>
    <content type="html"><![CDATA[<h2>Standard Protocols</h2>

<p>Ruby中定义了一些默认调用的方法，比如作为p 的参数时就会默认调用to_s
```
to_a
to_i
to_enum
to_hash
to_io
to_proc</p>

<h1>&hellip;&hellip;.</h1>

<p><code>
下面是Symbol中实现的to_proc
</code>
def to_proc
  proc {|obj, <em>args| obj.send(self,</em>args)}
end
```</p>

<h5>当用&amp;调用时就会去调用这个方法，我们自己的类实现这个后，也可有这个功能</h5>

<p>```
class A &lt; String
  def to_proc</p>

<pre><code>proc {|obj, *args| obj.send(:length,*args)}
</code></pre>

<p>  end
end
a = A.new
words = %w{bbb cccc fffff}
words.map(&amp;a)
```</p>

<h2>Coercions</h2>

<p>在operate操作时，判定应该谁调用谁，所以有时候是参数调用了receiver。返回的第一个是参数，第二个是应该作为receiver。
<code>
1.coerce(2.3) # =&gt; [2.3, 1.0]
</code>
可以自己实现这个方法
```
class A
  def coerce other</p>

<pre><code>#===在Module上调用时，是子类的意思，
#object上简单等同于==
if Fixnum === other 
  [other,2]
end
</code></pre>

<p>  end
end
a = A.new
1 + a</p>

<h1>=> 3</h1>

<p>a + 1 #如果要执行这个，先要def + other
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby的一些方法]]></title>
    <link href="http://itianzhu.github.io/blog/2013/12/22/rubyde-%5B%3F%5D-xie-fang-fa/"/>
    <updated>2013-12-22T21:06:53+08:00</updated>
    <id>http://itianzhu.github.io/blog/2013/12/22/rubyde-[?]-xie-fang-fa</id>
    <content type="html"><![CDATA[<p>```
ObjectSpace.each_object(Complex) {|x| puts x }</p>

<p>num.kind_of? Numeric #只要是类的父类即可
num.instance_of? Numeric #只能是实例所属类</p>

<p>Fixnum.ancestors #返回父类和模块的列表</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby中有趣的现象]]></title>
    <link href="http://itianzhu.github.io/blog/2013/12/22/rubyzhong-you-qu-de-xian-xiang/"/>
    <updated>2013-12-22T20:11:03+08:00</updated>
    <id>http://itianzhu.github.io/blog/2013/12/22/rubyzhong-you-qu-de-xian-xiang</id>
    <content type="html"><![CDATA[<h6>ruby命令执行实际上是在Object的类中执行的，其实定义的方法都是Object的private方法，然而我们又可以改变方法的可见性，而所有的类都是Object的子类，所以可以通过这个办法，给所有的类添加方法,而类本身是Class类的子类，所以所有的类也有了这个添加的方法</h6>

<p><code>
def mm
  p 'mm print'
end
public mm
'a'.mm # =&gt; "mm print"
2.mm # =&gt; "mm print"
class A
end
A.mm # =&gt; "mm print"
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby线程和进程]]></title>
    <link href="http://itianzhu.github.io/blog/2013/12/22/rubyxian-cheng-he-jin-cheng/"/>
    <updated>2013-12-22T00:04:56+08:00</updated>
    <id>http://itianzhu.github.io/blog/2013/12/22/rubyxian-cheng-he-jin-cheng</id>
    <content type="html"><![CDATA[<h3>线程的创建</h3>

<p><code>
thead = Thread.new("www.google.com") do |url|
  Thead.current[:count] = 1;
  http = Net::HTTP.new(url, 80)
  print "Fetching: #{url}\n"
  res = http.get('/')
  print "Got #{url}: #{res.message}\n"
  "hi"
end
thead.join
p thead[:count]
p thead.value
</code></p>

<h3>线程的方法</h3>

<p><code>
Thead#jion #主线程等待
Thead#value #等待返回Thead的最后一个代码的返回值
Thread#status
Thread#alive?
Thread#priority=
Thead#current
</code></p>

<h3>线程变量</h3>

<p><code>
Thead.current[:count] = 1;
</code></p>

<h3>线程异常</h3>

<p>如果没有调用thead.jo'in则线程里面的异常不会引起主线程的崩溃，如果调用join，可以通过设置类变量来避免
<code>
Thead.abort_on_exception = false
</code></p>

<h3>线程加锁</h3>

<p>```
mutex = Mutex.new
threads = 10.times.map do
  Thread.new do 100_000.times do
  mutex.lock</p>

<p>  mutex.unlock
end
<code>
或者
</code>
mutex = Mutex.new
threads = 10.times.map do
Thread.new do 100_000.times do
  mutex.synchronize do</p>

<p>  end
end
```</p>

<h5>如果想取得锁但是又不想暂停当前线程调用try_lock,如果想暂时解锁锁，可以调用sleep</h5>

<p>```
rate_mutex = Mutex.new
exchange_rates = ExchangeRates.new
exchange_rates.update_from_online_feed
  Thread.new do rate_mutex.lock
  loop do</p>

<pre><code>rate_mutex.sleep 3600
exchange_rates.update_from_online_feed
</code></pre>

<p>  end
end
loop do
  print &ldquo;Enter currency code and amount: &rdquo;
  line = gets
  if rate_mutex.try_lock</p>

<pre><code>puts(exchange_rates.convert(line)) ensure rate_mutex.unlock 
</code></pre>

<p>  else</p>

<pre><code>puts "Sorry, rates being updated. Try again in a minute" 
</code></pre>

<p>  end
end
```</p>

<h3>创建进程</h3>

<p>这两个方法是同步的，除了这两个，其它的都是不同步的，主进程可以先退出，而子进程不会被主进程退出
<code>
system("tar xzf test.tgz") # =&gt; true 只返回成功与否
`date` # =&gt; "Mon May 27 12:31:17 CDT 2013\n"
$? #返回最后一个进程的返回值
</code></p>

<h5>如果需要输入、输出。这些不是同步</h5>

<p>```
pig = IO.popen(&ldquo;local/util/pig&rdquo;, &ldquo;w+&rdquo;) pig.puts &ldquo;ice cream after they go to bed&rdquo; pig.close_write #发送end-of-file给pig的输入
puts pig.gets</p>

<h6>############ 我是分割线</h6>

<p>IO.popen(&ldquo;date&rdquo;) {|f| puts &ldquo;Date is #{f.gets}&rdquo; }</p>

<h6>############ 我是分割线</h6>

<p>fork do
  puts &ldquo;In child, pid = #$$&rdquo;
  exit 99
end
pid = Process.wait
puts &ldquo;Child terminated, pid = #{pid}, status = #{$?.exitstatus}&rdquo;</p>

<h1>produces:</h1>

<h1>In child, pid = 22033</h1>

<h1>Child terminated, pid = 22033, status = 99</h1>

<p>```</p>

<h3>子进程交互,只在支持fork的操作系统上有用，windows不支持</h3>

<p><code>
pipe = IO.popen("-","w+")  #进程的第一个参数必须为 "-" minus sign
if pipe
  pipe.puts "Get a job!"
  STDERR.puts "Child says '#{pipe.gets.chomp}'"
else
  这里是子进程执行的
  STDERR.puts "Dad says '#{gets.chomp}'"
  puts "OK"
end
</code></p>

<h3>独立子进程</h3>

<p>```
exec(&ldquo;sort testfile > output.txt&rdquo;) if fork.nil?</p>

<h1>exec在子进程执行，因为fork.nil在子进程中为真</h1>

<p>Process.wait</p>

<h6>####### 我是分割线</h6>

<p>trap(&ldquo;CLD&rdquo;) do
pid = Process.wait
puts &ldquo;Child pid #{pid}: terminated&rdquo;
end
fork { exec(&ldquo;sort testfile > output.txt&rdquo;) }</p>

<h1>produces:</h1>

<h1>Child pid 123456: terminated</h1>

<h6>####### 我是分割线</h6>

<h1>这个表明子进程不会退出</h1>

<p>fork do
  5.times do</p>

<pre><code>sleep 1
puts "I'm an orphan!"
</code></pre>

<p>  end
end</p>

<p>abort &ldquo;Parent process died&hellip;&rdquo;
```</p>
]]></content>
  </entry>
  
</feed>
