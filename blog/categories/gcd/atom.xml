<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: GCD | tz's Blog]]></title>
  <link href="http://itianzhu.github.io/blog/categories/gcd/atom.xml" rel="self"/>
  <link href="http://itianzhu.github.io/"/>
  <updated>2013-12-26T23:41:49+08:00</updated>
  <id>http://itianzhu.github.io/</id>
  <author>
    <name><![CDATA[tz]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Block 使用事项]]></title>
    <link href="http://itianzhu.github.io/blog/2013/12/18/block-shi-yong-shi-xiang/"/>
    <updated>2013-12-18T22:27:48+08:00</updated>
    <id>http://itianzhu.github.io/blog/2013/12/18/block-shi-yong-shi-xiang</id>
    <content type="html"><![CDATA[<p>block使用事项</p>

<p>1.block是NSObject的子类</p>

<p>2.运行时的block存在栈stack上，比如
{% codeblock lang:objc %}
void (^greetingBlock)(void);           //声明block变量
{  // scope begins, local variables pushed onto stack</p>

<pre><code>  //如 果没有此块的话，不会引起下面的stack pop off
</code></pre>

<p>  greetingBlock = ^{                   //定义blcok变量</p>

<pre><code>NSLog(@"Hello, World!");
</code></pre>

<p>  };
}  // scope ends, stack variables (e.g. the block literal) popped off stack
greetingBlock();  // Block invocation may cause the program to crash!
{% endcodeblock %}</p>

<p>3.block有block_copy()和block_release()方法，来保存在堆上。比如
{% codeblock lang:objc %}
void (^greetingBlock)(void);
{
  greetingBlock = [^{</p>

<pre><code>NSLog(@"Hello, World!");
</code></pre>

<p>} copy]; }
greetingBlock();          // Block invocation works (uses heap storage)
[greetingBlock release];  // released block to prevent memory leak
{% endcodeblock %}
或者
{% codeblock lang:objc %}
void (^greetingBlock)(id salutation);
{
  greetingBloc
  k = Block_copy(^(id salutation){
  NSLog(@&ldquo;%@, World!&rdquo;, salutation);
  });
}
greetingBlock(@&ldquo;Hello&rdquo;);
Block_release(greetingBlock);
{% endcodeblock %}
4.<strong>block变量的处理。在MRR下，不会自动retain这个_block变量。在ARC下，会自动retain，如果不要此默认行为，需要替换使用</strong>weak。</p>

<p>5.在block中使用self,而不产生引用循环，。在MRR下,4里面说过，在这种情况下，_block变量不会retain，但是要注意当[self dealloc]之后不能再调用block：
{% codeblock lang:objc %}
__block ClassName *that = self;
self.block = ^(CGFloat percentComplete) {</p>

<pre><code>[that doSome];
</code></pre>

<p>}
{% endcodeblock %}
在ARC下，使用<strong>weak,当对象dealloc之后，会自动置为nil。
{% codeblock lang:objc %}
</strong>weak ClassName <em>that = self;
__unsafe_unretained ClassName </em>that = self;//for iOS 4.x and up
self.block = ^(CGFloat percentComplete) {</p>

<pre><code>ClassName *this = that;//(1)
[that doSome];
</code></pre>

<p>}//(2)
{% endcodeblock %}
如果有第(1)步，则会在block中产生一个本地的<strong>strong变量，而ARC中所有的变量默认都是</strong>strong的，这样会导致这个变量retained，而这个this本地变量会在第(2)处被释放掉。</p>
]]></content>
  </entry>
  
</feed>
